<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Anonymization Visualization | Before & After</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" />

    <style>
        :root {
            --primary-theme-color: #009688;
            --muted-text-color: #5a6e87;
            --particle-color: rgba(0, 150, 136, 0.6);
        }

        body {
            background: linear-gradient(-45deg, #e0f2f1, #e3f2fd, #e8f5e9, #e0f2f1);
            background-size: 400% 400%;
            animation: gradient-animation 20s ease infinite;
            font-family: 'Segoe UI', sans-serif;
            color: #2a3f5a;
            overflow-x: hidden;
        }

        @keyframes gradient-animation {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        canvas#interactive-canvas {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: -1;
        }

        .card-glass {
            background-color: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(8px);
            border-radius: 1rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.1);
        }

        .btn-primary, .btn-outline-secondary {
            border-radius: 2rem;
        }

        .btn-primary {
            background-color: var(--primary-theme-color);
            border-color: var(--primary-theme-color);
            font-weight: 500;
            padding: 0.6rem 1.2rem;
        }

        footer {
            color: var(--muted-text-color);
        }
    </style>
</head>
<body>

<canvas id="interactive-canvas"></canvas>

<div class="container-xl py-5">
    <header class="text-center mb-5">
        <a href="/">
            <img src="{{ url_for('static', filename='Images/inv1.png') }}" alt="InviseeAI Logo" class="img-fluid mb-3" style="max-width: 150px;">
        </a>
        <h1 class="fw-bold">Anonymization Comparison Visualizer</h1>
        <p class="text-muted">
            Visualize your dataset before and after applying anonymization techniques like <strong>k-anonymity</strong>, <strong>ℓ-diversity</strong>, and <strong>t-closeness</strong>.
        </p>
    </header>

    <div class="card-glass p-4 mb-4">
        <!-- Controls -->
        <form id="visualization-form" class="mb-4">
            <div class="row g-3 align-items-end">
                <div class="col-md-3">
                    <label for="chart-type" class="form-label">Chart Type</label>
                    <select id="chart-type" class="form-select">
                        <option value="bar">Bar Chart</option>
                        <option value="pie">Pie Chart</option>
                        <option value="histogram">Histogram</option>
                        <option value="box">Box Plot</option>
                        <option value="scatter">Scatter Plot</option>
                    </select>
                </div>
                <div class="col-md-3">
                    <label for="column-x" class="form-label">X-Axis Column</label>
                    <select id="column-x" class="form-select">
                        {% for col in columns %}
                            <option value="{{ col }}">{{ col }}</option>
                        {% endfor %}
                    </select>
                </div>
                <div class="col-md-3 d-none" id="column-y-wrapper">
                    <label for="column-y" class="form-label">Y-Axis Column</label>
                    <select id="column-y" class="form-select">
                        {% for col in columns %}
                            <option value="{{ col }}">{{ col }}</option>
                        {% endfor %}
                    </select>
                </div>
                <div class="col-md-3 d-none" id="histogram-bins-wrapper">
                    <label for="histogram-bins" class="form-label">Histogram Bins (<span id="bins-value">20</span>)</label>
                    <input type="range" id="histogram-bins" class="form-range" min="5" max="50" value="20">
                </div>
                <div class="col-12">
                    <button type="submit" class="btn btn-primary w-100">Generate Charts</button>
                </div>
            </div>
        </form>

        <!-- CHARTS SIDE BY SIDE -->
        <div class="row">
            <div class="col-md-6 mb-4">
                <h5 class="text-center mb-3">Before Anonymization</h5>
                <div id="chart-before" style="min-height: 400px;"></div>
            </div>
            <div class="col-md-6 mb-4">
                <h5 class="text-center mb-3">After Anonymization</h5>
                <div id="chart-after" style="min-height: 400px;"></div>
            </div>
        </div>

        <!-- Back Button -->
        <div class="text-center">
            <a href="{{ url_for('preview') }}" class="btn btn-outline-secondary px-4">
                <i class="fas fa-arrow-left me-2"></i>Back to Workspace
            </a>
        </div>
    </div>
</div>

<!-- Footer -->
<footer class="text-center py-4 small">
    &copy; {{ 2025 }} InviseeAI — All rights reserved.
</footer>

<script>
    const DATA_BEFORE = {{ df_original_json | safe }};
    const DATA_AFTER = {{ df_json | safe }};

    const PLOTLY_LAYOUT = {
        plot_bgcolor: 'rgba(0,0,0,0)',
        paper_bgcolor: 'rgba(0,0,0,0)',
        font: { family: 'Segoe UI', color: '#333' },
        height: 400,
        margin: { t: 50, b: 60, l: 50, r: 30 }
    };

    const NUMBER_REGEX = /^-?\d+(?:[.,]\d+)?$/;
    const RANGE_REGEX = /^(-?\d+(?:\.\d+)?)-(-?\d+(?:\.\d+)?)$/;

    function getCategoryCounts(data, column) {
        const counts = data.reduce((acc, row) => {
            const val = row[column] || "N/A";
            acc[val] = (acc[val] || 0) + 1;
            return acc;
        }, {});
        return { labels: Object.keys(counts), values: Object.values(counts) };
    }

    function coerceNumeric(value) {
        if (value === null || value === undefined) {
            return null;
        }

        if (typeof value === "number") {
            return Number.isFinite(value) ? value : null;
        }

        if (typeof value !== "string") {
            return null;
        }

        const trimmed = value.trim();
        if (!trimmed || trimmed === "*") {
            return null;
        }

        const normalized = trimmed.replace(/,/g, ".");
        if (NUMBER_REGEX.test(normalized)) {
            const numeric = parseFloat(normalized);
            return Number.isFinite(numeric) ? numeric : null;
        }

        const dashNormalized = normalized
            .replace(/\u2013/g, "-")
            .replace(/\s+(?:to)\s+/gi, "-")
            .replace(/\s*-\s*/g, "-");

        const match = dashNormalized.match(RANGE_REGEX);
        if (match) {
            const start = parseFloat(match[1]);
            const end = parseFloat(match[2]);
            if (Number.isFinite(start) && Number.isFinite(end)) {
                return (start + end) / 2;
            }
        }

        return null;
    }

    function toNumericSeries(data, column) {
        return data.reduce((acc, row) => {
            const numeric = coerceNumeric(row[column]);
            if (numeric !== null) {
                acc.push(numeric);
            }
            return acc;
        }, []);
    }

    function toNumericPairs(data, xCol, yCol) {
        return data.reduce((acc, row) => {
            const xVal = coerceNumeric(row[xCol]);
            const yVal = coerceNumeric(row[yCol]);
            if (xVal !== null && yVal !== null) {
                acc.push({ x: xVal, y: yVal });
            }
            return acc;
        }, []);
    }

    function renderEmpty(chartId, message) {
        const layout = Object.assign({}, PLOTLY_LAYOUT, {
            annotations: [{
                text: message,
                x: 0.5,
                y: 0.5,
                xref: "paper",
                yref: "paper",
                showarrow: false,
                font: { size: 14, color: "#6c757d" }
            }]
        });
        Plotly.react(chartId, [], layout);
    }

    function draw(data, chartId, type, xCol, yCol = null, bins = 20) {
        if (!data || !data.length) {
            renderEmpty(chartId, "No records available for visualisation.");
            return;
        }

        let traceData = [];
        const layout = Object.assign({}, PLOTLY_LAYOUT);

        switch (type) {
            case "bar":
                const barCounts = getCategoryCounts(data, xCol);
                if (!barCounts.labels.length) {
                    renderEmpty(chartId, `Column "${xCol}" has no values to display.`);
                    return;
                }
                traceData = [{
                    type: "bar",
                    x: barCounts.labels,
                    y: barCounts.values
                }];
                break;
            case "pie":
                const pieCounts = getCategoryCounts(data, xCol);
                if (!pieCounts.labels.length) {
                    renderEmpty(chartId, `Column "${xCol}" has no values to display.`);
                    return;
                }
                traceData = [{
                    type: "pie",
                    labels: pieCounts.labels,
                    values: pieCounts.values
                }];
                break;
            case "histogram":
                const histogramSeries = toNumericSeries(data, xCol);
                if (!histogramSeries.length) {
                    renderEmpty(chartId, `Column "${xCol}" has no numeric data for a histogram.`);
                    return;
                }
                traceData = [{
                    type: "histogram",
                    x: histogramSeries,
                    nbinsx: bins
                }];
                break;
            case "box":
                const boxSeries = toNumericSeries(data, xCol);
                if (!boxSeries.length) {
                    renderEmpty(chartId, `Column "${xCol}" has no numeric data for a box plot.`);
                    return;
                }
                traceData = [{
                    type: "box",
                    y: boxSeries,
                    name: xCol
                }];
                break;
            case "scatter":
                if (!yCol) {
                    renderEmpty(chartId, "Select a Y-axis column for the scatter plot.");
                    return;
                }
                const pairs = toNumericPairs(data, xCol, yCol);
                if (!pairs.length) {
                    renderEmpty(
                        chartId,
                        `Columns "${xCol}" and "${yCol}" need numeric data for a scatter plot.`
                    );
                    return;
                }
                traceData = [{
                    type: "scatter",
                    mode: "markers",
                    x: pairs.map(p => p.x),
                    y: pairs.map(p => p.y)
                }];
                break;
            default:
                renderEmpty(chartId, "Unsupported chart type.");
                return;
        }
        Plotly.react(chartId, traceData, layout);
    }

    document.addEventListener("DOMContentLoaded", () => {
        const form = document.getElementById("visualization-form");
        const chartTypeSelect = document.getElementById("chart-type");
        const colXSelect = document.getElementById("column-x");
        const colYSelect = document.getElementById("column-y");
        const colYWrapper = document.getElementById("column-y-wrapper");
        const binsInput = document.getElementById("histogram-bins");
        const binsWrapper = document.getElementById("histogram-bins-wrapper");
        const binsValueSpan = document.getElementById("bins-value");

        chartTypeSelect.addEventListener("change", () => {
            const type = chartTypeSelect.value;
            colYWrapper.classList.toggle("d-none", type !== "scatter");
            binsWrapper.classList.toggle("d-none", type !== "histogram");
        });

        binsInput.addEventListener("input", () => {
            binsValueSpan.textContent = binsInput.value;
        });

        form.addEventListener("submit", e => {
            e.preventDefault();
            const type = chartTypeSelect.value;
            const x = colXSelect.value;
            const y = colYSelect.value;
            const b = parseInt(binsInput.value, 10);
            draw(DATA_BEFORE, "chart-before", type, x, y, b);
            draw(DATA_AFTER, "chart-after", type, x, y, b);
        });

        // Particle Background
        const canvas = document.getElementById("interactive-canvas");
        const ctx = canvas.getContext("2d");
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        class Particle {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.size = Math.random() * 2 + 1;
                this.dx = (Math.random() - 0.5) * 0.8;
                this.dy = (Math.random() - 0.5) * 0.8;
            }
            update() {
                this.x += this.dx;
                this.y += this.dy;
                if (this.x < 0 || this.x > canvas.width) this.dx *= -1;
                if (this.y < 0 || this.y > canvas.height) this.dy *= -1;
            }
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--particle-color');
                ctx.fill();
            }
        }

        const particles = Array.from({ length: 80 }, () => new Particle());

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            particles.forEach(p => {
                p.update();
                p.draw();
            });
            requestAnimationFrame(animate);
        }

        animate();

        window.addEventListener("resize", () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
    });
</script>

</body>
</html>
